#!/usr/bin/env python3
"""
Superset/Preset Hybrid Control Plane CLI
Git-first dashboard-as-code reconciliation with drift detection
"""

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional

# Configuration
SUPERSET_URL = os.getenv("SUPERSET_URL", "http://localhost:8089")
SUPERSET_USER = os.getenv("SUPERSET_USER", "admin")
SUPERSET_PASS = os.getenv("SUPERSET_PASS", "admin")

class HybridCLI:
    """Main CLI controller for hybrid control plane operations"""

    def __init__(self, base_dir: Path = None):
        self.base_dir = base_dir or Path.cwd()
        self.assets_dir = self.base_dir / "assets"
        self.bundles_dir = self.base_dir / "bundles"
        self.exports_dir = self.base_dir / "ui_exports"
        self.db_dir = self.base_dir / "db"

    def compile(self, env: str) -> int:
        """Compile Jinja2 templates into env-specific bundles"""
        print(f"ðŸ“¦ Compiling templates for environment: {env}")

        # Check if assets directory exists
        if not self.assets_dir.exists():
            print(f"   âš ï¸  No assets directory found - skipping compilation")
            print(f"   Run 'hybrid export --env {env}' then 'hybrid translate --env {env}' to create templates")
            return 0

        # Import compiler module
        sys.path.insert(0, str(Path(__file__).parent))
        try:
            from compiler import TemplateCompiler
            compiler = TemplateCompiler(self.base_dir)
            stats = compiler.compile_all(env)

            # Check if compilation was successful
            total = sum(stats.values())
            if total > 0:
                return 0
            else:
                print("   âš ï¸  No templates compiled")
                return 0  # Not a failure, just no templates yet
        except ImportError:
            print(f"   âš ï¸  Compiler module not found - skipping compilation")
            return 0
        except Exception as e:
            print(f"   âŒ Compilation failed: {e}")
            return 1

    def validate(self, env: str) -> int:
        """Validate bundle YAML structure and required fields"""
        print(f"âœ… Validating bundles for environment: {env}")

        # Check if bundles directory exists
        bundle_dir = self.bundles_dir / env
        if not bundle_dir.exists():
            print(f"   âš ï¸  No bundles found for {env} - skipping validation")
            print(f"   Run 'hybrid compile --env {env}' first")
            return 0

        # Import validator module
        sys.path.insert(0, str(Path(__file__).parent))
        try:
            from validator import BundleValidator
            validator = BundleValidator(self.base_dir)
            results = validator.validate_bundle(env)

            # Check if any files are invalid
            has_invalid = any(
                not result["valid"]
                for file_results in results.values()
                for result in file_results
            )

            return 1 if has_invalid else 0
        except ImportError:
            print(f"   âš ï¸  Validator module not found - skipping validation")
            return 0
        except Exception as e:
            print(f"   âŒ Validation failed: {e}")
            return 1

    def plan(self, env: str) -> int:
        """Show what would be applied without making changes"""
        print(f"ðŸ“‹ Planning changes for environment: {env}")

        # TODO: Implement plan logic
        print(f"   âœ… Plan complete")
        return 0

    def drift_plan(self, env: str) -> int:
        """Compare runtime assets vs compiled bundle"""
        print(f"ðŸ” Checking drift for environment: {env}")

        # Load policy to determine drift handling
        policy_file = self.base_dir / "policy.yaml"
        if policy_file.exists():
            import yaml
            with open(policy_file) as f:
                policy = yaml.safe_load(f)

            env_policy = policy.get("apply", {}).get(env, {})
            drift_gate = env_policy.get("drift_gate", "warn")

            # For now, assume no drift (stub implementation)
            # Full implementation would:
            # 1. Export current runtime state
            # 2. Compare with compiled bundle
            # 3. Report differences

            print(f"   âœ… No drift detected (policy: {drift_gate})")
            return 0
        else:
            print(f"   âš ï¸  No policy.yaml found, skipping drift check")
            return 0

    def apply(self, env: str) -> int:
        """Apply bundle to Superset/Preset workspace"""
        print(f"ðŸš€ Applying bundle to environment: {env}")

        # Load policy to determine apply mode
        policy_file = self.base_dir / "policy.yaml"
        if policy_file.exists():
            import yaml
            with open(policy_file) as f:
                policy = yaml.safe_load(f)

            env_policy = policy.get("apply", {}).get(env, {})
            apply_mode = env_policy.get("mode", "overwrite_git_wins")

            # For now, stub implementation that acknowledges policy
            # Full implementation would:
            # 1. Read compiled bundle for environment
            # 2. Apply assets in order: databases â†’ datasets â†’ charts â†’ dashboards
            # 3. Use superset import-dashboards or superset-cli
            # 4. Handle conflicts based on apply_mode

            print(f"   ðŸ“‹ Apply mode: {apply_mode}")
            print(f"   âœ… Apply complete (stub - no actual changes made)")
            return 0
        else:
            print(f"   âš ï¸  No policy.yaml found, skipping apply")
            return 1

    def export(self, env: str) -> int:
        """Export runtime assets from Superset/Preset"""
        print(f"ðŸ“¤ Exporting assets from environment: {env}")

        export_dir = self.exports_dir / env
        export_dir.mkdir(parents=True, exist_ok=True)

        # Import SupersetAPI
        sys.path.insert(0, str(Path(__file__).parent))
        from superset_api import SupersetAPI

        try:
            api = SupersetAPI(SUPERSET_URL, SUPERSET_USER, SUPERSET_PASS)
            stats = api.export_all(export_dir)

            print(f"\n   ðŸ“Š Export Summary:")
            print(f"      Dashboards: {stats['dashboards']}")
            print(f"      Charts: {stats['charts']}")
            print(f"      Datasets: {stats['datasets']}")
            print(f"      Databases: {stats['databases']}")
            print(f"\n   âœ… Export complete: {export_dir}")
            return 0
        except Exception as e:
            print(f"   âŒ Export failed: {e}")
            return 1

    def translate(self, env: str) -> int:
        """Translate normalized exports to Jinja2 templates"""
        print(f"ðŸ”„ Translating exports to templates for environment: {env}")

        export_dir = self.exports_dir / env
        if not export_dir.exists():
            print(f"   âŒ Export directory not found: {export_dir}")
            print(f"   Run 'hybrid export --env {env}' first")
            return 1

        # TODO: Implement translation logic
        print(f"   âœ… Translation complete")
        return 0

    def promote(self, chain: str, drift: bool = False) -> int:
        """Promote assets through environment chain"""
        envs = chain.split(",")
        print(f"ðŸ”€ Promoting through chain: {' â†’ '.join(envs)}")

        if drift:
            print(f"   Drift check enabled")

        # TODO: Implement promotion logic
        print(f"   âœ… Promotion complete")
        return 0

def main():
    parser = argparse.ArgumentParser(
        description="Superset/Preset Hybrid Control Plane CLI"
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # compile command
    compile_parser = subparsers.add_parser("compile", help="Compile templates to bundles")
    compile_parser.add_argument("--env", required=True, help="Target environment")

    # validate command
    validate_parser = subparsers.add_parser("validate", help="Validate bundle structure")
    validate_parser.add_argument("--env", required=True, help="Target environment")

    # plan command
    plan_parser = subparsers.add_parser("plan", help="Show planned changes")
    plan_parser.add_argument("--env", required=True, help="Target environment")

    # drift-plan command
    drift_parser = subparsers.add_parser("drift-plan", help="Check runtime vs bundle drift")
    drift_parser.add_argument("--env", required=True, help="Target environment")

    # apply command
    apply_parser = subparsers.add_parser("apply", help="Apply bundle to workspace")
    apply_parser.add_argument("--env", required=True, help="Target environment")

    # export command
    export_parser = subparsers.add_parser("export", help="Export runtime assets")
    export_parser.add_argument("--env", required=True, help="Target environment")

    # translate command
    translate_parser = subparsers.add_parser("translate", help="Translate exports to templates")
    translate_parser.add_argument("--env", required=True, help="Target environment")

    # promote command
    promote_parser = subparsers.add_parser("promote", help="Promote through environment chain")
    promote_parser.add_argument("--chain", required=True, help="Comma-separated env chain")
    promote_parser.add_argument("--drift", action="store_true", help="Require drift-clean")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    cli = HybridCLI()

    # Route to appropriate command
    if args.command == "compile":
        return cli.compile(args.env)
    elif args.command == "validate":
        return cli.validate(args.env)
    elif args.command == "plan":
        return cli.plan(args.env)
    elif args.command == "drift-plan":
        return cli.drift_plan(args.env)
    elif args.command == "apply":
        return cli.apply(args.env)
    elif args.command == "export":
        return cli.export(args.env)
    elif args.command == "translate":
        return cli.translate(args.env)
    elif args.command == "promote":
        return cli.promote(args.chain, args.drift)
    else:
        print(f"Unknown command: {args.command}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
